<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>GitStatusChecker</h1>
      <dl>
        <dt>throws TypeError for non-object options</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new GitStatusChecker(true); },
  TypeError,
  /\boptions\b/,
);</code></pre></dd>
        <dt>throws TypeError for non-Readable in</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new GitStatusChecker({ in: new stream.Writable() }); },
  TypeError,
  /\boptions.in\b/,
);</code></pre></dd>
        <dt>throws TypeError for non-Writable out</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new GitStatusChecker({ out: new stream.Readable() }); },
  TypeError,
  /\boptions.out\b/,
);</code></pre></dd>
        <dt>returns Error for non-Writable err</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new GitStatusChecker({ err: new stream.Readable() }); },
  TypeError,
  /\boptions.err\b/,
);</code></pre></dd>
        <section class="suite">
          <h1>.checkSlugFormat()</h1>
          <dl>
            <dt>accepts &#x22;owner/repo&#x22;</dt>
            <dd><pre><code>const result = GitStatusChecker.checkSlugFormat(slug);
assert.strictEqual(result, slug);</code></pre></dd>
            <dt>accepts &#x22;owner-1/repo-1&#x22;</dt>
            <dd><pre><code>const result = GitStatusChecker.checkSlugFormat(slug);
assert.strictEqual(result, slug);</code></pre></dd>
            <dt>rejects &#x22;repo&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;/owner/repo&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;/repo&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;owner/&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;owner//repo&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;owner/repo/&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;owner/repo/branch&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22; owner/repo&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;owner /repo&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;owner/ repo&#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
            <dt>rejects &#x22;owner/repo &#x22;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { GitStatusChecker.checkSlugFormat(slug); },
  InvalidSlugError,
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#resolveHash()</h1>
          <dl>
            <dt>can resolve the hash of HEAD</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
return checker.resolveHash(&#x27;HEAD&#x27;).then((hash) =&#x3E; {
  assert.match(hash, /^[a-fA-F0-9]{40}$/);
  headHash = hash;
});</code></pre></dd>
            <dt>can resolve a hash to itself</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
return checker.resolveHash(headHash).then((hash) =&#x3E; {
  assert.strictEqual(hash, headHash);
});</code></pre></dd>
            <dt>rejects with Error for unresolvable name</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
return checker.resolveHash(&#x27;notabranch&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert(err);
  },
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#storeSlug()</h1>
          <dl>
            <dt>can store a valid slug</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
const testSlug = &#x27;foo/bar&#x27;;
return checker.storeSlug(testSlug).then((slug) =&#x3E; {
  assert.strictEqual(slug, testSlug);
  return git(&#x27;config&#x27;, &#x27;--get&#x27;, GitStatusChecker.SLUG_CONFIG_NAME)
    .then((result) =&#x3E; {
      const configSlug = result[0].trimRight();
      assert.strictEqual(configSlug, testSlug);
    });
});</code></pre></dd>
            <dt>returns Error for an invalid slug</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
const testSlug = &#x27;foobar&#x27;;
return checker.storeSlug(testSlug).then(
  sinon.mock().never(),
  (errStore) =&#x3E; {
    assert.instanceOf(errStore, InvalidSlugError);
    return git(&#x27;config&#x27;, &#x27;--get&#x27;, GitStatusChecker.SLUG_CONFIG_NAME)
      .then(
        (configSlug) =&#x3E; {
          assert.fail(configSlug, null, &#x27;slug should not be stored&#x27;);
        },
        (errGit) =&#x3E; (errGit.code === 1 ? null : Promise.reject(errGit)),
      );
  },
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#tryStoreSlug()</h1>
          <dl>
            <dt>can store a valid slug</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
const testSlug = &#x27;foo/bar&#x27;;
return checker.tryStoreSlug(testSlug).then((slug) =&#x3E; {
  assert.strictEqual(slug, testSlug);
  return git(&#x27;config&#x27;, &#x27;--get&#x27;, GitStatusChecker.SLUG_CONFIG_NAME)
    .then((result) =&#x3E; {
      const configSlug = result[0].trimRight();
      assert.strictEqual(configSlug, testSlug);
    });
});</code></pre></dd>
            <dt>prints error message for an invalid slug</dt>
            <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const checker = new GitStatusChecker({
  out: outStream,
  err: errStream,
});
const testSlug = &#x27;foobar&#x27;;
return checker.tryStoreSlug(testSlug).then((slug) =&#x3E; {
  assert.strictEqual(slug, testSlug);
  assert.strictEqual(outStream.read(), null);
  assert.match(String(errStream.read()), /error/i);
  return git(&#x27;config&#x27;, &#x27;--get&#x27;, GitStatusChecker.SLUG_CONFIG_NAME)
    .then(
      (configSlug) =&#x3E; {
        assert.fail(configSlug, null, &#x27;slug should not be stored&#x27;);
      },
      (errGit) =&#x3E; (errGit.code === 1 ? null : Promise.reject(errGit)),
    );
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#confirmSlug()</h1>
          <dl>
            <dt>prompts user for confirmation</dt>
            <dd><pre><code>const inStream = new stream.PassThrough();
const outStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const errStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const checker = new GitStatusChecker({
  in: inStream,
  out: outStream,
  err: errStream,
});
const testSlug = &#x27;foo/bar&#x27;;
const confirmP = checker.confirmSlug(testSlug);
return read(errStream)
  .then((promptMsg) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(promptMsg, /correct/i);
    assert.include(promptMsg, testSlug);
    inStream.write(&#x27;y\n&#x27;);
    return confirmP;
  })
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, testSlug);
    assert.strictEqual(outStream.read(), null);
    assert.strictEqual(errStream.read(), null);
  });</code></pre></dd>
            <dt>prompts user for slug if not confirmed</dt>
            <dd><pre><code>const inStream = new stream.PassThrough();
const outStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const errStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const checker = new GitStatusChecker({
  in: inStream,
  out: outStream,
  err: errStream,
});
const testSlug1 = &#x27;foo/bar&#x27;;
const testSlug2 = &#x27;baz/quux&#x27;;
const confirmP = checker.confirmSlug(testSlug1);
return read(errStream)
  .then((promptMsg1) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(promptMsg1, /correct/i);
    assert.include(promptMsg1, testSlug1);
    inStream.write(&#x27;n\n&#x27;);
    return read(errStream);
  })
  .then((promptMsg2) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(promptMsg2, /repository/i);
    assert.include(promptMsg2, testSlug1);
    inStream.write(&#x60;${testSlug2}\n&#x60;);
    return confirmP;
  }).then((slug) =&#x3E; {
    assert.strictEqual(slug, testSlug2);
    assert.strictEqual(outStream.read(), null);
    assert.strictEqual(errStream.read(), null);
  });</code></pre></dd>
            <dt>re-prompts user if slug is invalid</dt>
            <dd><pre><code>const inStream = new stream.PassThrough();
const outStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const errStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const checker = new GitStatusChecker({
  in: inStream,
  out: outStream,
  err: errStream,
});
const testSlug1 = &#x27;foo/bar&#x27;;
const testSlug2 = &#x27;fred&#x27;;
const testSlug3 = &#x27;baz/quux&#x27;;
const confirmP = checker.confirmSlug(testSlug1);
return read(errStream)
  .then((promptMsg1) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(promptMsg1, /correct/i);
    assert.include(promptMsg1, testSlug1);
    inStream.write(&#x27;n\n&#x27;);
    return read(errStream);
  })
  .then((promptMsg2) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(promptMsg2, /repository/i);
    assert.include(promptMsg2, testSlug1);
    inStream.write(&#x60;${testSlug2}\n&#x60;);
    return read(errStream);
  })
  .then((errorMsg) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(errorMsg, /invalid/i);
    // Prompt may be part of error message or not
    if (errorMsg.includes(testSlug1)) {
      return errorMsg;
    }
    return read(errStream);
  })
  .then((promptMsg3) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(promptMsg3, /repository/i);
    assert.include(promptMsg3, testSlug1);
    inStream.write(&#x60;${testSlug3}\n&#x60;);
    return confirmP;
  })
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, testSlug3);
    assert.strictEqual(outStream.read(), null);
    assert.strictEqual(errStream.read(), null);
  });</code></pre></dd>
            <dt>rejects with EOFError if input ends</dt>
            <dd><pre><code>const inStream = new stream.PassThrough();
const outStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const errStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const checker = new GitStatusChecker({
  in: inStream,
  out: outStream,
  err: errStream,
});
const testSlug = &#x27;foo/bar&#x27;;
const confirmP = checker.confirmSlug(testSlug)
  .then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.strictEqual(err.name, &#x27;EOFError&#x27;);
      // Same message as travis.rb
      assert.strictEqual(err.message, &#x27;The input stream is exhausted.&#x27;);
      // Doesn&#x27;t print error message itself, but calling code will
      assert.strictEqual(outStream.read(), null);
      assert.strictEqual(errStream.read(), null);
    },
  );
const promptP = read(errStream)
  .then((promptMsg) =&#x3E; {
    assert.strictEqual(outStream.read(), null);
    assert.match(promptMsg, /correct/i);
    assert.include(promptMsg, testSlug);
    // End without newline (e.g. user hit ^D before return)
    inStream.end(&#x27;y&#x27;);
  });
return Promise.all([confirmP, promptP]);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#detectBranch()</h1>
          <dl>
            <dt>resolves master on master</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
return git(&#x27;checkout&#x27;, &#x27;master&#x27;)
  .then(() =&#x3E; checker.detectBranch())
  .then((branch) =&#x3E; {
    assert.strictEqual(branch, &#x27;master&#x27;);
  });</code></pre></dd>
            <dt>resolves branch1 on branch1</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
return git(&#x27;checkout&#x27;, &#x27;branch1&#x27;)
  .then(() =&#x3E; checker.detectBranch())
  .then((branch) =&#x3E; {
    assert.strictEqual(branch, &#x27;branch1&#x27;);
  });</code></pre></dd>
            <dt>rejects with Error not on branch</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
return git(&#x27;checkout&#x27;, &#x27;HEAD^&#x27;)
  .then(() =&#x3E; checker.detectBranch())
  .then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.match(err.message, /branch/i);
    },
  );</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#detectSlug()</h1>
          <dl>
            <dt>resolves owner1/repo1 for branch1</dt>
            <dd><pre><code>const checker = new GitStatusChecker({
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
});
return git(&#x27;checkout&#x27;, branchName)
  .then(() =&#x3E; checker.detectSlug())
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, remoteSlug);
  });</code></pre></dd>
            <dt>resolves owner2/repo2 for branch2</dt>
            <dd><pre><code>const checker = new GitStatusChecker({
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
});
return git(&#x27;checkout&#x27;, branchName)
  .then(() =&#x3E; checker.detectSlug())
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, remoteSlug);
  });</code></pre></dd>
            <dt>resolves owner3/repo3 for branch3</dt>
            <dd><pre><code>const checker = new GitStatusChecker({
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
});
return git(&#x27;checkout&#x27;, branchName)
  .then(() =&#x3E; checker.detectSlug())
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, remoteSlug);
  });</code></pre></dd>
            <dt>defaults to origin if branch has no remote</dt>
            <dd><pre><code>const checker = new GitStatusChecker({
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
});
return git(&#x27;checkout&#x27;, &#x27;master&#x27;)
  .then(() =&#x3E; checker.detectSlug())
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, REMOTE_SLUGS.origin);
  });</code></pre></dd>
            <dt>defaults to origin if not on branch</dt>
            <dd><pre><code>const checker = new GitStatusChecker({
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
});
return git(&#x27;checkout&#x27;, &#x27;HEAD^&#x27;)
  .then(() =&#x3E; checker.detectSlug())
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, REMOTE_SLUGS.origin);
  });</code></pre></dd>
            <dt>rejects with SlugDetectionError for remote with no URL</dt>
            <dd><pre><code>const checker = new GitStatusChecker({
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
});
return git(&#x27;checkout&#x27;, &#x27;branchnourl&#x27;)
  .then(() =&#x3E; checker.detectSlug())
  .then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.strictEqual(err.name, &#x27;SlugDetectionError&#x27;);
      assert.match(err.message, /remote/i);
    },
  );</code></pre></dd>
            <dt>rejects with SlugDetectionError for remote without slug</dt>
            <dd><pre><code>const checker = new GitStatusChecker({
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
});
return git(&#x27;checkout&#x27;, &#x27;branchnotslug&#x27;)
  .then(() =&#x3E; checker.detectSlug())
  .then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.strictEqual(err.name, &#x27;SlugDetectionError&#x27;);
      assert.match(err.message, /URL/i);
    },
  );</code></pre></dd>
            <dt>prompts for confirmation if interactive</dt>
            <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const checker = new GitStatusChecker({
  interactive: true,
  out: outStream,
  err: errStream,
});
const testSlug = &#x27;prompt/slug&#x27;;
const mock = sinon.mock(checker);
mock.expects(&#x27;confirmSlug&#x27;)
  .once().withExactArgs(REMOTE_SLUGS.origin).returns(testSlug);
return git(&#x27;checkout&#x27;, &#x27;master&#x27;)
  .then(() =&#x3E; checker.detectSlug())
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, testSlug);
    // Only output is from prompt (which is mocked)
    assert.strictEqual(outStream.read(), null);
    assert.strictEqual(errStream.read(), null);
  });</code></pre></dd>
            <dt>prints result without confirmation if not interactive</dt>
            <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const checker = new GitStatusChecker({
  out: outStream,
  err: errStream,
});
const mock = sinon.mock(checker);
mock.expects(&#x27;confirmSlug&#x27;).never();
return git(&#x27;checkout&#x27;, &#x27;master&#x27;)
  .then(() =&#x3E; checker.detectSlug())
  .then((slug) =&#x3E; {
    assert.strictEqual(slug, REMOTE_SLUGS.origin);
    assert.strictEqual(outStream.read(), null);
    // From travis.rb
    const detectMsg = &#x60;detected repository as ${slug}\n&#x60;;
    assert.strictEqual(errStream.read(), detectMsg);
  });</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#loadSlug()</h1>
          <dl>
            <dt>loads slug set by #storeSlug()</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
const testSlug = &#x27;foo/bar&#x27;;
return checker.storeSlug(testSlug)
  .then(() =&#x3E; checker.loadSlug().then((slug) =&#x3E; {
    assert.strictEqual(slug, testSlug);
  }));</code></pre></dd>
            <dt>resolves null if slug is not set</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
return checker.loadSlug().then((slug) =&#x3E; {
  assert.strictEqual(slug, null);
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#findSlug()</h1>
          <dl>
            <dt>uses #loadSlug() result if non-null</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
const testSlug = &#x27;foo/bar&#x27;;
const mock = sinon.mock(checker);
mock.expects(&#x27;loadSlug&#x27;)
  .once().withExactArgs().returns(Promise.resolve(testSlug));
mock.expects(&#x27;detectSlug&#x27;).never();
return checker.findSlug().then((slug) =&#x3E; {
  assert.strictEqual(slug, testSlug);
});</code></pre></dd>
            <dt>uses #detectSlug() result if #loadSlug() is null</dt>
            <dd><pre><code>const checker = new GitStatusChecker();
const testSlug = &#x27;foo/bar&#x27;;
const mock = sinon.mock(checker);
mock.expects(&#x27;loadSlug&#x27;)
  .once().withExactArgs().returns(Promise.resolve(null));
mock.expects(&#x27;detectSlug&#x27;)
  .once().withExactArgs().returns(Promise.resolve(testSlug));
return checker.findSlug().then((slug) =&#x3E; {
  assert.strictEqual(slug, testSlug);
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>travisStatus integration</h1>
      <dl>
        <dt>fetches branch state</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testBranch = &#x27;branch1&#x27;;
const testOpts = { slug: testSlug, branch: testBranch };
const testResult = apiResponses.branch(testOpts);
apiMock.expects(&#x27;branch&#x27;)
  .once().withExactArgs(match(testOpts))
  .returns(testResult);
apiMock.expects(&#x27;build&#x27;).never();
apiMock.expects(&#x27;repo&#x27;).never();
const options = {
  apiEndpoint: apiUrl,
  branch: testBranch,
  repo: testSlug,
};
return travisStatus(options).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  apiMock.verify();
  assert.strictEqual(connCount, 1);
});</code></pre></dd>
        <dt>fetches repo state</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testOpts = { slug: testSlug };
const testResult = apiResponses.repo(testOpts);
apiMock.expects(&#x27;branch&#x27;).never();
apiMock.expects(&#x27;build&#x27;).never();
apiMock.expects(&#x27;repo&#x27;)
  .once().withExactArgs(match(testOpts))
  .returns(testResult);
const options = {
  apiEndpoint: apiUrl,
  repo: testSlug,
};
return travisStatus(options).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  apiMock.verify();
  assert.strictEqual(connCount, 1);
});</code></pre></dd>
        <dt>fetches repo and build for commit</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testCommit = &#x27;4e2c26acca22601fb54da35485faff7c303084eb&#x27;;
const testBuildId = 123456;
const testOpts = {
  buildId: testBuildId,
  sha: testCommit,
  slug: testSlug,
};
const testBuild = apiResponses.build(testOpts);
const testRepo = apiResponses.repo(testOpts);
apiMock.expects(&#x27;branch&#x27;).never();
apiMock.expects(&#x27;build&#x27;)
  .once().withExactArgs(match({ buildId: String(testBuildId) }))
  .returns(testBuild);
apiMock.expects(&#x27;repo&#x27;)
  .once().withExactArgs(match({ slug: testSlug }))
  .returns(testRepo);
const options = {
  apiEndpoint: apiUrl,
  commit: testCommit,
  repo: testSlug,
};
return travisStatus(options).then((result) =&#x3E; {
  assert.deepEqual(result, { ...testRepo, ...testBuild });
  apiMock.verify();
  // If Agent doesn&#x27;t have .destroy(), travisStatus can&#x27;t do keep-alive.
  // TODO:  Check that travisStatusCmd does.
  if (typeof new http.Agent().destroy === &#x27;function&#x27;) {
    assert.strictEqual(connCount, 1);
  }
});</code></pre></dd>
        <dt>fetches repo state with wait</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const pendingResult =
  apiResponses.repo({ slug: testSlug, state: &#x27;started&#x27; });
const passedResult = apiResponses.repo({ slug: testSlug });
apiMock.expects(&#x27;branch&#x27;).never();
apiMock.expects(&#x27;build&#x27;).never();
const expect = apiMock.expects(&#x27;repo&#x27;)
  .atLeast(2)
  .withExactArgs(match({ slug: testSlug }));
// We don&#x27;t want to over-specify the timeout/backoff values.
// So extra calls are added to ensure it is long enough to exceed the
// keep-alive timeout.
for (let i = 0; i &#x3C; 5; i += 1) {
  expect.onCall(i).returns(pendingResult);
}
expect.onCall(5).returns(passedResult);
const options = {
  apiEndpoint: apiUrl,
  repo: testSlug,
  wait: Infinity,
};
const promise = travisStatus(options).then((result) =&#x3E; {
  assert.deepEqual(result, passedResult);
  apiMock.verify();
});
return promise;</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>TravisStatusChecker</h1>
      <dl>
        <dt>throws TypeError for non-object options</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new TravisStatusChecker(true); },
  TypeError,
  /\boptions\b/,
);</code></pre></dd>
        <dt>passes {pro: true} to Travis when apiEndpoint is PRO_URI</dt>
        <dd><pre><code>TravisMock = sinon.mock()
  .once()
  .withExactArgs(
    match({ pro: true }),
  );
// eslint-disable-next-line no-new
new TravisStatusChecker({
  apiEndpoint: TravisStatusChecker.PRO_URI,
});
TravisMock.verify();</code></pre></dd>
        <dt>passes options.token to agent.setAccessToken</dt>
        <dd><pre><code>const testToken = &#x27;123456&#x27;;
travisHttpMock = new TravisStatusHttp();
const mock = sinon.mock(travisHttpMock);
mock.expects(&#x27;setAccessToken&#x27;).once().withExactArgs(testToken);
// eslint-disable-next-line no-new
new TravisStatusChecker({
  token: testToken,
});
mock.verify();</code></pre></dd>
        <section class="suite">
          <h1>#getBranch()</h1>
          <dl>
            <dt>returns Travis CI API resource</dt>
            <dd><pre><code>travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise = checker[methodName](...args)
  .then((response) =&#x3E; {
    assert.deepEqual(response, passedResponse);
  });
travisRequestMock.verify();
return promise;</code></pre></dd>
            <section class="suite">
              <h1>with options.wait</h1>
              <dl>
                <dt>does not wait if state is not pending</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, passedResponse);
    });
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>retries during wait if state is pending</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .twice()
  .withArgs(match(/GET/i), match(travisUrlRe));
travisRequestMock.onFirstCall().yields(null, pendingResponse);
travisRequestMock.onSecondCall().yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, passedResponse);
    });
for (let i = 1; i &#x3C; 11; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>returns pending state if wait elapses</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .atLeast(1)
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, pendingResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, pendingResponse);
    });
for (let i = 1; i &#x3C; 11; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>does not wait after API error</dt>
                <dd><pre><code>const errTest = new Error(&#x27;Test API error&#x27;);
travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(errTest);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 30000 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err, errTest);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>stops waiting after API error</dt>
                <dd><pre><code>const errTest = new Error(&#x27;Test API error&#x27;);
travisRequestMock = sinon.mock()
  .twice()
  .withArgs(match(/GET/i), match(travisUrlRe));
travisRequestMock.onFirstCall().yields(null, pendingResponse);
travisRequestMock.onSecondCall().yields(errTest);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 30000 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err, errTest);
      },
    );
for (let i = 1; i &#x3C; 31; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>rejects with TypeError for non-number wait</dt>
                <dd><pre><code>travisRequestMock = sinon.mock().never();
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: &#x27;hello&#x27; }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;TypeError&#x27;);
        assert.match(err.message, /\bwait\b/);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>rejects with RangeError for negative wait</dt>
                <dd><pre><code>travisRequestMock = sinon.mock().never();
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: -5 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;RangeError&#x27;);
        assert.match(err.message, /\bwait\b/);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#getBuild()</h1>
          <dl>
            <dt>returns Travis CI API resource</dt>
            <dd><pre><code>travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise = checker[methodName](...args)
  .then((response) =&#x3E; {
    assert.deepEqual(response, passedResponse);
  });
travisRequestMock.verify();
return promise;</code></pre></dd>
            <section class="suite">
              <h1>with options.wait</h1>
              <dl>
                <dt>does not wait if state is not pending</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, passedResponse);
    });
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>retries during wait if state is pending</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .twice()
  .withArgs(match(/GET/i), match(travisUrlRe));
travisRequestMock.onFirstCall().yields(null, pendingResponse);
travisRequestMock.onSecondCall().yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, passedResponse);
    });
for (let i = 1; i &#x3C; 11; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>returns pending state if wait elapses</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .atLeast(1)
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, pendingResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, pendingResponse);
    });
for (let i = 1; i &#x3C; 11; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>does not wait after API error</dt>
                <dd><pre><code>const errTest = new Error(&#x27;Test API error&#x27;);
travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(errTest);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 30000 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err, errTest);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>stops waiting after API error</dt>
                <dd><pre><code>const errTest = new Error(&#x27;Test API error&#x27;);
travisRequestMock = sinon.mock()
  .twice()
  .withArgs(match(/GET/i), match(travisUrlRe));
travisRequestMock.onFirstCall().yields(null, pendingResponse);
travisRequestMock.onSecondCall().yields(errTest);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 30000 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err, errTest);
      },
    );
for (let i = 1; i &#x3C; 31; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>rejects with TypeError for non-number wait</dt>
                <dd><pre><code>travisRequestMock = sinon.mock().never();
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: &#x27;hello&#x27; }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;TypeError&#x27;);
        assert.match(err.message, /\bwait\b/);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>rejects with RangeError for negative wait</dt>
                <dd><pre><code>travisRequestMock = sinon.mock().never();
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: -5 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;RangeError&#x27;);
        assert.match(err.message, /\bwait\b/);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>#getRepo()</h1>
          <dl>
            <dt>returns Travis CI API resource</dt>
            <dd><pre><code>travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise = checker[methodName](...args)
  .then((response) =&#x3E; {
    assert.deepEqual(response, passedResponse);
  });
travisRequestMock.verify();
return promise;</code></pre></dd>
            <section class="suite">
              <h1>with options.wait</h1>
              <dl>
                <dt>does not wait if state is not pending</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, passedResponse);
    });
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>retries during wait if state is pending</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .twice()
  .withArgs(match(/GET/i), match(travisUrlRe));
travisRequestMock.onFirstCall().yields(null, pendingResponse);
travisRequestMock.onSecondCall().yields(null, passedResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, passedResponse);
    });
for (let i = 1; i &#x3C; 11; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>returns pending state if wait elapses</dt>
                <dd><pre><code>travisRequestMock = sinon.mock()
  .atLeast(1)
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(null, pendingResponse);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 10000 }))
    .then((response) =&#x3E; {
      assert.deepEqual(response, pendingResponse);
    });
for (let i = 1; i &#x3C; 11; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>does not wait after API error</dt>
                <dd><pre><code>const errTest = new Error(&#x27;Test API error&#x27;);
travisRequestMock = sinon.mock()
  .once()
  .withArgs(match(/GET/i), match(travisUrlRe))
  .yields(errTest);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 30000 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err, errTest);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>stops waiting after API error</dt>
                <dd><pre><code>const errTest = new Error(&#x27;Test API error&#x27;);
travisRequestMock = sinon.mock()
  .twice()
  .withArgs(match(/GET/i), match(travisUrlRe));
travisRequestMock.onFirstCall().yields(null, pendingResponse);
travisRequestMock.onSecondCall().yields(errTest);
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: 30000 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err, errTest);
      },
    );
for (let i = 1; i &#x3C; 31; i += 1) {
  clock.tick(1000);
}
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>rejects with TypeError for non-number wait</dt>
                <dd><pre><code>travisRequestMock = sinon.mock().never();
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: &#x27;hello&#x27; }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;TypeError&#x27;);
        assert.match(err.message, /\bwait\b/);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
                <dt>rejects with RangeError for negative wait</dt>
                <dd><pre><code>travisRequestMock = sinon.mock().never();
const checker = new TravisStatusChecker();
const promise =
  checker[methodName](...args.concat({ wait: -5 }))
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;RangeError&#x27;);
        assert.match(err.message, /\bwait\b/);
      },
    );
travisRequestMock.verify();
return promise;</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>travis-status command</h1>
      <dl>
        <dt>accepts empty arguments</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    match.any,
    match.func,
  );
travisStatusCmd([], sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>returns undefined when called with a function</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    match.any,
    match.func,
  );
const result = travisStatusCmd(RUNTIME_ARGS, sinon.mock().never());
travisStatus.verify();
assert.strictEqual(result, undefined);</code></pre></dd>
        <dt>default interactive true for TTY stdout</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    match({ interactive: true }),
    match.func,
  );
const outStream = new stream.PassThrough();
outStream.isTTY = true;
const options = {
  out: outStream,
  err: new stream.PassThrough(),
};
travisStatusCmd(RUNTIME_ARGS, options, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets  as match(apiEndpoint: undefined, branch: undefined, commit: undefined, repo: undefined, requestOpts: not insecure, storeRepo: undefined, token: undefined, wait: undefined)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --api-endpoint https://example.com as match(apiEndpoint: https://example.com)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --branch branchname as match(branch: branchname)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --branch as match(branch: true)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --commit v1.0.0 as match(commit: v1.0.0)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --commit as match(commit: HEAD)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --debug as typeOf(&#x22;object&#x22;)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --debug-http as typeOf(&#x22;object&#x22;)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --explode as typeOf(&#x22;object&#x22;)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --insecure as match(requestOpts: match(strictSSL: false))</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --interactive as match(interactive: true)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --org as match(apiEndpoint: https://api.travis-ci.org/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --pro as match(apiEndpoint: https://api.travis-ci.com/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --repo foo/bar as match(repo: foo/bar)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --skip-completion-check as typeOf(&#x22;object&#x22;)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --skip-version-check as typeOf(&#x22;object&#x22;)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --staging as match(apiEndpoint: https://api-staging.travis-ci.org/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --org --staging as match(apiEndpoint: https://api-staging.travis-ci.org/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --pro --staging as match(apiEndpoint: https://api-staging.travis-ci.com/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --store-repo foo/bar as match(storeRepo: foo/bar)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --token 12345 as match(token: 12345)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --wait 60 as match(wait: 60000)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --wait as match(wait: Infinity)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -E as typeOf(&#x22;object&#x22;)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -I as match(requestOpts: match(strictSSL: false))</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -R foo/bar as match(storeRepo: foo/bar)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -b branchname as match(branch: branchname)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -b as match(branch: true)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -c v1.0.0 as match(commit: v1.0.0)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -c as match(commit: HEAD)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -e https://example.com as match(apiEndpoint: https://example.com)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -i as match(interactive: true)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -r foo/bar as match(repo: foo/bar)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -t 12345 as match(token: 12345)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -w 60 as match(wait: 60000)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets -w as match(wait: Infinity)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --repo foo/bar --store-repo baz/quux as match(repo: baz/quux, storeRepo: baz/quux)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --store-repo foo/bar --repo baz/quux as match(repo: baz/quux, storeRepo: foo/bar)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --api-endpoint https://example.com --org --pro as match(apiEndpoint: https://api.travis-ci.com/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --pro --org --api-endpoint https://example.com as match(apiEndpoint: https://example.com)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --pro --staging as match(apiEndpoint: https://api-staging.travis-ci.com/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>interprets --staging --pro as match(apiEndpoint: https://api.travis-ci.com/)</dt>
        <dd><pre><code>travisStatus = sinon.mock()
  .once()
  .withArgs(
    expectObj,
    match.func,
  );
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, sinon.mock().never());
travisStatus.verify();</code></pre></dd>
        <dt>prints error and exits for -w nope</dt>
        <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  assert.match(String(errStream.read()), expectErrMsg);
  done();
});</code></pre></dd>
        <dt>prints error and exits for --unknown</dt>
        <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  assert.match(String(errStream.read()), expectErrMsg);
  done();
});</code></pre></dd>
        <dt>prints error and exits for extraarg</dt>
        <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  assert.match(String(errStream.read()), expectErrMsg);
  done();
});</code></pre></dd>
        <dt>normally exits with code 0 if build failed</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with -x exits with code 1 if build canceled</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with -x exits with code 1 if build errored</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with -x exits with code 1 if build failed</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with --exit-code exits with code 1 if build canceled</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with --exit-code exits with code 1 if build errored</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with --exit-code exits with code 1 if build failed</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>normally exits with code 0 if build queued</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with -p exits with code 1 if build created</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with -p exits with code 1 if build queued</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with -p exits with code 1 if build received</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with -p exits with code 1 if build started</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with --fail-pending exits with code 1 if build created</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with --fail-pending exits with code 1 if build queued</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with --fail-pending exits with code 1 if build received</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>with --fail-pending exits with code 1 if build started</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const allArgs = RUNTIME_ARGS.concat(args);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>-q exits without printing state</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat(arg);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  assert.strictEqual(outStream.read(), null);
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state: &#x27;failed&#x27; }),
);</code></pre></dd>
        <dt>--quiet exits without printing state</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat(arg);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  assert.strictEqual(outStream.read(), null);
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state: &#x27;failed&#x27; }),
);</code></pre></dd>
        <dt>prints build number and state for repo to stdout</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const buildNum = 500;
const state = &#x27;passed&#x27;;
const allArgs = RUNTIME_ARGS.concat(isBranch ? [&#x27;--branch&#x27;] : []);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  assert.strictEqual(
    String(outStream.read()),
    // We are strict about this format since other programs may use it
    &#x60;build #${buildNum} ${state}\n&#x60;,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  isBranch
    ? apiResponses.branch({ number: buildNum, state })
    : apiResponses.repo({ number: buildNum, state }),
);</code></pre></dd>
        <dt>prints build number and state for branch to stdout</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const buildNum = 500;
const state = &#x27;passed&#x27;;
const allArgs = RUNTIME_ARGS.concat(isBranch ? [&#x27;--branch&#x27;] : []);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  assert.strictEqual(
    String(outStream.read()),
    // We are strict about this format since other programs may use it
    &#x60;build #${buildNum} ${state}\n&#x60;,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  isBranch
    ? apiResponses.branch({ number: buildNum, state })
    : apiResponses.repo({ number: buildNum, state }),
);</code></pre></dd>
        <dt>prints canceled in red if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints created in yellow if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints errored in red if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints failed in red if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints passed in green if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints queued in yellow if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints ready in green if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints received in yellow if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints started in yellow if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  const outString = String(outStream.read());
  assert.include(
    outString,
    ansiStyles[color].open + state + ansiStyles[color].close,
  );
  assert.strictEqual(errStream.read(), null);
  done();
});
travisStatus.yield(
  null,
  apiResponses.repo({ state }),
);</code></pre></dd>
        <dt>prints error messages in red if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const errMsg = &#x27;super duper test error&#x27;;
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  const errString = String(errStream.read());
  assert.include(errString, ansiStyles.red.open);
  assert.include(errString, errMsg);
  done();
});
travisStatus.yield(new Error(errMsg));</code></pre></dd>
        <dt>returns TypeError for non-array-like args</dt>
        <dd><pre><code>travisStatusCmd({}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\bargs\b/);
  done();
});</code></pre></dd>
        <dt>returns RangeError for single argument</dt>
        <dd><pre><code>travisStatusCmd([&#x27;node&#x27;], (err) =&#x3E; {
  assert.instanceOf(err, RangeError);
  assert.match(err.message, /\bargs\b/);
  done();
});</code></pre></dd>
        <dt>throws for non-function callback</dt>
        <dd><pre><code>assert.throws(
  () =&#x3E; { travisStatusCmd(RUNTIME_ARGS, {}, true); },
  TypeError,
  /\bcallback\b/,
);</code></pre></dd>
        <dt>returns Error for non-object options</dt>
        <dd><pre><code>travisStatusCmd([], true, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions\b/);
  done();
});</code></pre></dd>
        <dt>returns Error for non-Readable in</dt>
        <dd><pre><code>travisStatusCmd([], { in: new stream.Writable() }, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.in\b/);
  done();
});</code></pre></dd>
        <dt>returns Error for non-Writable out</dt>
        <dd><pre><code>travisStatusCmd([], { out: new stream.Readable() }, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.out\b/);
  done();
});</code></pre></dd>
        <dt>returns Error for non-Writable err</dt>
        <dd><pre><code>travisStatusCmd([], { err: new stream.Readable() }, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.err\b/);
  done();
});</code></pre></dd>
        <dt>prints error messages in red if interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const errMsg = &#x27;super duper test error&#x27;;
const allArgs = RUNTIME_ARGS.concat([&#x27;--interactive&#x27;]);
travisStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  const errString = String(errStream.read());
  assert.include(errString, ansiStyles.red.open);
  assert.include(errString, errMsg);
  done();
});
travisStatus.yield(new Error(errMsg));</code></pre></dd>
        <dt>prints error messages without color if not interactive</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
const errMsg = &#x27;super duper test error&#x27;;
travisStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  const errString = String(errStream.read());
  assert(!hasAnsi(errString), &#x27;string has color&#x27;);
  assert.include(errString, errMsg);
  done();
});
travisStatus.yield(new Error(errMsg));</code></pre></dd>
        <dt>prints a help message for SlugDetectionError</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  out: outStream,
  err: errStream,
};
travisStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  assert.match(String(errStream.read()), /\brepo name\b.*-r/i);
  done();
});
travisStatus.yield(new SlugDetectionError(&#x27;oops&#x27;));</code></pre></dd>
        <dt>returns a Promise when called without a function</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const result = travisStatusCmd(RUNTIME_ARGS);
assert(result instanceof Promise);</code></pre></dd>
        <dt>returned Promise is resolved with exit code</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const options = {
  out: new stream.PassThrough(),
  err: new stream.PassThrough(),
};
const result = travisStatusCmd(RUNTIME_ARGS, options);
travisStatus.yield(
  null,
  apiResponses.repo(),
);
return result.then((code) =&#x3E; {
  assert.strictEqual(code, 0);
});</code></pre></dd>
        <dt>returned Promise is rejected with Error</dt>
        <dd><pre><code>travisStatus = sinon.stub();
const result = travisStatusCmd(RUNTIME_ARGS, true);
return result.then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.instanceOf(err, TypeError); },
);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>TravisStatusHttp</h1>
      <dl>
        <dt>throws TypeError for non-string endpoint</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new TravisStatusHttp(true); },
  TypeError,
  /\bendpoint\b/,
);</code></pre></dd>
        <dt>throws TypeError for non-object options</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new TravisStatusHttp(null, true); },
  TypeError,
  /\boptions\b/,
);</code></pre></dd>
        <section class="suite">
          <h1>#request()</h1>
          <dl>
            <dt>accepts Travis and JSON media types by default</dt>
            <dd><pre><code>const status = new TravisStatusHttp();
request = sinon.mock()
  .once()
  .withArgs(match({
    headers: match({
      Accept: match((accept) =&#x3E; {
        const travisRE = /^application\/vnd\.travis-ci\.2\+json(?:,|$)/;
        return travisRE.test(accept)
          &#x26;&#x26; / application\/json(?:,|$)/.test(accept);
      }, &#x27;match Travis and JSON media types&#x27;),
    }),
  }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>can send custom accept header</dt>
            <dd><pre><code>const testAccept = &#x27;text/plain&#x27;;
// Note:  Testing lower case properly replaces upper
const status =
  new TravisStatusHttp(null, { headers: { accept: testAccept } });
request = sinon.mock()
  .once()
  .withArgs(match({
    headers: match({
      Accept: undefined,
      accept: testAccept,
    }),
  }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>supports gzip by default</dt>
            <dd><pre><code>const status = new TravisStatusHttp();
request = sinon.mock()
  .once()
  .withArgs(match({ gzip: true }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>sends User-Agent including module version by default</dt>
            <dd><pre><code>const uaVersionRE = new RegExp(&#x60;node-travis-status/${
  packageJson.version.replace(/\./g, &#x27;\\.&#x27;)}&#x60;);
const status = new TravisStatusHttp();
request = sinon.mock()
  .once()
  .withArgs(match({
    headers: match({
      &#x27;User-Agent&#x27;: match(uaVersionRE),
    }),
  }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>can send custom user-agent header</dt>
            <dd><pre><code>const testUA = &#x27;Test Agent&#x27;;
// Note:  Testing lower case properly replaces upper
const status =
  new TravisStatusHttp(null, { headers: { &#x27;user-agent&#x27;: testUA } });
request = sinon.mock()
  .once()
  .withArgs(match({
    headers: match({
      &#x27;User-Agent&#x27;: undefined,
      &#x27;user-agent&#x27;: testUA,
    }),
  }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>builds Authorization header from setAccessToken</dt>
            <dd><pre><code>const testToken = &#x27;12345&#x27;;
const status = new TravisStatusHttp();
status.setAccessToken(testToken);
request = sinon.mock()
  .once()
  .withArgs(match({
    headers: match({
      Authorization: &#x60;token ${testToken}&#x60;,
    }),
  }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>builds quoted Authorization header from setAccessToken</dt>
            <dd><pre><code>const testToken = &#x27;12345&#x22;67\\89&#x27;;
const quotedToken = &#x27;&#x22;12345\\&#x22;67\\\\89&#x22;&#x27;;
const status = new TravisStatusHttp();
status.setAccessToken(testToken);
request = sinon.mock()
  .once()
  .withArgs(match({
    headers: match({
      Authorization: &#x60;token ${quotedToken}&#x60;,
    }),
  }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>setAccessToken overrides options.headers.Authorization</dt>
            <dd><pre><code>const testToken = &#x27;12345&#x27;;
const status =
  new TravisStatusHttp(null, { headers: { Authorization: &#x27;foo&#x27; } });
status.setAccessToken(testToken);
request = sinon.mock()
  .once()
  .withArgs(match({
    headers: match({
      Authorization: &#x60;token ${testToken}&#x60;,
    }),
  }));
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, () =&#x3E; {});
request.verify();</code></pre></dd>
            <dt>returns errors from request</dt>
            <dd><pre><code>const errTest = new Error(&#x27;Test request error&#x27;);
const status = new TravisStatusHttp();
request = sinon.mock().once().yields(errTest);
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, (err) =&#x3E; {
  assert.strictEqual(err, errTest);
});
request.verify();</code></pre></dd>
            <dt>returns errors for HTTP status &#x3E;= 400</dt>
            <dd><pre><code>const status = new TravisStatusHttp();
const errProps = {
  statusCode: 400,
  statusMessage: &#x27;Test Message&#x27;,
  headers: {
    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,
    test: &#x27;ok&#x27;,
  },
};
const testBody = { test: &#x27;stuff&#x27; };
const testBodyStr = JSON.stringify(testBody);
const response = new http.IncomingMessage();
Object.assign(response, errProps);
request = sinon.mock().once().yields(null, response, testBodyStr);
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, (err) =&#x3E; {
  assert.strictEqual(err.message, errProps.statusMessage);
  assert.deepEqual(
    { ...err },
    { body: testBody, ...errProps },
  );
});
request.verify();</code></pre></dd>
            <dt>returns errors for non-JSON</dt>
            <dd><pre><code>const status = new TravisStatusHttp();
const errProps = {
  statusCode: 200,
  statusMessage: &#x27;Test Message&#x27;,
  headers: {
    &#x27;Content-Type&#x27;: &#x27;text/plain&#x27;,
    test: &#x27;ok&#x27;,
  },
};
const testBody = &#x27;Body?&#x27;;
let testErr;
try { JSON.parse(testBody); } catch (errJson) { testErr = errJson; }
const response = new http.IncomingMessage();
Object.assign(response, errProps);
request = sinon.mock().once().yields(null, response, testBody);
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, (err) =&#x3E; {
  assert.strictEqual(err.message, testErr.message);
  assert.deepEqual(
    { ...err },
    { body: testBody, ...errProps },
  );
});
request.verify();</code></pre></dd>
            <dt>returns HTTP errors in preference to JSON</dt>
            <dd><pre><code>const status = new TravisStatusHttp();
const errProps = {
  statusCode: 400,
  statusMessage: &#x27;Test Message&#x27;,
  headers: {
    &#x27;Content-Type&#x27;: &#x27;text/plain&#x27;,
    test: &#x27;ok&#x27;,
  },
};
const testBody = &#x27;Body?&#x27;;
const response = new http.IncomingMessage();
Object.assign(response, errProps);
request = sinon.mock().once().yields(null, response, testBody);
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, (err) =&#x3E; {
  assert.strictEqual(err.message, errProps.statusMessage);
  assert.deepEqual(
    { ...err },
    { body: testBody, ...errProps },
  );
});
request.verify();</code></pre></dd>
            <dt>returns body JSON without Error</dt>
            <dd><pre><code>const status = new TravisStatusHttp();
const errProps = {
  statusCode: 200,
  statusMessage: &#x27;Test Message&#x27;,
  headers: {
    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,
    test: &#x27;ok&#x27;,
  },
};
const testBody = { prop: &#x27;OK&#x27; };
const testBodyStr = JSON.stringify(testBody);
const response = new http.IncomingMessage();
Object.assign(response, errProps);
request = sinon.mock().once().yields(null, response, testBodyStr);
status.request(&#x27;GET&#x27;, &#x27;/repos&#x27;, (err, body) =&#x3E; {
  assert.deepEqual(body, testBody);
});
request.verify();</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>travisStatus</h1>
      <dl>
        <dt>fetches current repo without storing by default</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;findSlug&#x27;)
  .once().withExactArgs().returns(Promise.resolve(testSlug));
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
return travisStatus().then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>fetches current repo and stores if interactive</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;findSlug&#x27;)
  .once().withExactArgs().returns(Promise.resolve(testSlug));
gitCheckerMock.expects(&#x27;storeSlug&#x27;)
  .once().withExactArgs(testSlug).returns(Promise.resolve(testSlug));
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
return travisStatus({ interactive: true }).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>fetches options.repo</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
return travisStatus({ repo: testSlug }).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>fetches and stores options.storeRepo</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;storeSlug&#x27;)
  .once().withExactArgs(testSlug).returns(Promise.resolve(testSlug));
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
return travisStatus({ storeRepo: testSlug }).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>fetches options.repo, stores options.storeRepo</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testSlug2 = &#x27;baz/quux&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;storeSlug&#x27;)
  .once().withExactArgs(testSlug2).returns(Promise.resolve(testSlug2));
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
const options = { repo: testSlug, storeRepo: testSlug2 };
return travisStatus(options).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>fetches named branch for options.branch</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testBranch = &#x27;branch1&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;detectBranch&#x27;).never();
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;).never();
travisCheckerMock.expects(&#x27;getBranch&#x27;)
  .once().withArgs(testSlug, testBranch)
  .returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
const options = { branch: testBranch, repo: testSlug };
return travisStatus(options).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>fetches current branch for true options.branch</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testBranch = &#x27;branch1&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;detectBranch&#x27;)
  .once().withExactArgs().returns(Promise.resolve(testBranch));
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;).never();
travisCheckerMock.expects(&#x27;getBranch&#x27;)
  .once().withArgs(testSlug, testBranch)
  .returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
const options = { branch: true, repo: testSlug };
return travisStatus(options).then((result) =&#x3E; {
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>resolves combined result for same commit hash</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testHash = &#x27;692064aac95441e2dae7f1780fccc536143a0863&#x27;;
const apiHash = isSameHash ? testHash : &#x60;${testHash.slice(0, -1)}0&#x60;;
const testCommit = commitIsHash ? testHash : &#x27;v2.0.0&#x27;;
const testRepo = apiResponses.repo({
  slug: testSlug,
});
const testBuild = apiResponses.build({ sha: apiHash });
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;resolveHash&#x27;)
  .once().withExactArgs(testCommit).returns(Promise.resolve(testHash));
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testRepo));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;)
  .once().withArgs(testSlug, testRepo.repo.last_build_id)
  .returns(Promise.resolve(testBuild));
const statusP = travisStatus({ commit: testCommit, repo: testSlug });
let testP;
if (isSameHash) {
  testP = statusP.then((result) =&#x3E; {
    assert.deepEqual(result, { ...testRepo, ...testBuild });
  });
} else {
  testP = statusP.then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.match(err.message, /\bcommit\b/i);
      assert.include(err.message, testCommit);
      assert.include(err.message, testHash);
      assert.include(err.message, apiHash);
    },
  );
}
return testP.then(() =&#x3E; {
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>resolves combined result for matching commit name</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testHash = &#x27;692064aac95441e2dae7f1780fccc536143a0863&#x27;;
const apiHash = isSameHash ? testHash : &#x60;${testHash.slice(0, -1)}0&#x60;;
const testCommit = commitIsHash ? testHash : &#x27;v2.0.0&#x27;;
const testRepo = apiResponses.repo({
  slug: testSlug,
});
const testBuild = apiResponses.build({ sha: apiHash });
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;resolveHash&#x27;)
  .once().withExactArgs(testCommit).returns(Promise.resolve(testHash));
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testRepo));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;)
  .once().withArgs(testSlug, testRepo.repo.last_build_id)
  .returns(Promise.resolve(testBuild));
const statusP = travisStatus({ commit: testCommit, repo: testSlug });
let testP;
if (isSameHash) {
  testP = statusP.then((result) =&#x3E; {
    assert.deepEqual(result, { ...testRepo, ...testBuild });
  });
} else {
  testP = statusP.then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.match(err.message, /\bcommit\b/i);
      assert.include(err.message, testCommit);
      assert.include(err.message, testHash);
      assert.include(err.message, apiHash);
    },
  );
}
return testP.then(() =&#x3E; {
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>rejects with Error for same commit hash</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testHash = &#x27;692064aac95441e2dae7f1780fccc536143a0863&#x27;;
const apiHash = isSameHash ? testHash : &#x60;${testHash.slice(0, -1)}0&#x60;;
const testCommit = commitIsHash ? testHash : &#x27;v2.0.0&#x27;;
const testRepo = apiResponses.repo({
  slug: testSlug,
});
const testBuild = apiResponses.build({ sha: apiHash });
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;resolveHash&#x27;)
  .once().withExactArgs(testCommit).returns(Promise.resolve(testHash));
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testRepo));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;)
  .once().withArgs(testSlug, testRepo.repo.last_build_id)
  .returns(Promise.resolve(testBuild));
const statusP = travisStatus({ commit: testCommit, repo: testSlug });
let testP;
if (isSameHash) {
  testP = statusP.then((result) =&#x3E; {
    assert.deepEqual(result, { ...testRepo, ...testBuild });
  });
} else {
  testP = statusP.then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.match(err.message, /\bcommit\b/i);
      assert.include(err.message, testCommit);
      assert.include(err.message, testHash);
      assert.include(err.message, apiHash);
    },
  );
}
return testP.then(() =&#x3E; {
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>rejects with Error for matching commit name</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testHash = &#x27;692064aac95441e2dae7f1780fccc536143a0863&#x27;;
const apiHash = isSameHash ? testHash : &#x60;${testHash.slice(0, -1)}0&#x60;;
const testCommit = commitIsHash ? testHash : &#x27;v2.0.0&#x27;;
const testRepo = apiResponses.repo({
  slug: testSlug,
});
const testBuild = apiResponses.build({ sha: apiHash });
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;resolveHash&#x27;)
  .once().withExactArgs(testCommit).returns(Promise.resolve(testHash));
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testRepo));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;)
  .once().withArgs(testSlug, testRepo.repo.last_build_id)
  .returns(Promise.resolve(testBuild));
const statusP = travisStatus({ commit: testCommit, repo: testSlug });
let testP;
if (isSameHash) {
  testP = statusP.then((result) =&#x3E; {
    assert.deepEqual(result, { ...testRepo, ...testBuild });
  });
} else {
  testP = statusP.then(
    sinon.mock().never(),
    (err) =&#x3E; {
      assert.match(err.message, /\bcommit\b/i);
      assert.include(err.message, testCommit);
      assert.include(err.message, testHash);
      assert.include(err.message, apiHash);
    },
  );
}
return testP.then(() =&#x3E; {
  gitCheckerMock.verify();
  travisCheckerMock.verify();
});</code></pre></dd>
        <dt>rejects with TypeError for non-object options</dt>
        <dd><pre><code>travisStatus(true)
    .then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;TypeError&#x27;);
        assert.match(err.message, /\boptions\b/);
      },
    )</code></pre></dd>
        <dt>throws TypeError for non-function callback</dt>
        <dd><pre><code>assert.throws(
  () =&#x3E; { travisStatus({}, true); },
  TypeError,
  /\bcallback\b/,
);</code></pre></dd>
        <dt>rejects with InvalidSlugError for invalid options.repo</dt>
        <dd><pre><code>gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;).never();
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
return travisStatus({ repo: &#x27;invalid&#x27; }).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;InvalidSlugError&#x27;);
    gitCheckerMock.verify();
    travisCheckerMock.verify();
  },
);</code></pre></dd>
        <dt>rejects with InvalidSlugError for invalid options.storeRepo</dt>
        <dd><pre><code>gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;).never();
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
return travisStatus({ storeRepo: &#x27;invalid&#x27; }).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;InvalidSlugError&#x27;);
    gitCheckerMock.verify();
    travisCheckerMock.verify();
  },
);</code></pre></dd>
        <dt>yields result to callback without returning Promise</dt>
        <dd><pre><code>const testSlug = &#x27;foo/bar&#x27;;
const testResult = {};
gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;findSlug&#x27;)
  .once().withExactArgs().returns(Promise.resolve(testSlug));
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;)
  .once().withArgs(testSlug).returns(Promise.resolve(testResult));
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
const retVal = travisStatus((err, result) =&#x3E; {
  assert.strictEqual(err, null);
  assert.deepEqual(result, testResult);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
  done();
});
assert.strictEqual(retVal, undefined);</code></pre></dd>
        <dt>yields Error to callback without returning Promise</dt>
        <dd><pre><code>gitChecker = new GitStatusChecker();
const gitCheckerMock = sinon.mock(gitChecker);
gitCheckerMock.expects(&#x27;storeSlug&#x27;).never();
gitCheckerMock.expects(&#x27;findSlug&#x27;).never();
travisChecker = new TravisStatusChecker();
const travisCheckerMock = sinon.mock(travisChecker);
travisCheckerMock.expects(&#x27;getRepo&#x27;).never();
travisCheckerMock.expects(&#x27;getBranch&#x27;).never();
travisCheckerMock.expects(&#x27;getBuild&#x27;).never();
const retVal = travisStatus({ repo: &#x27;invalid&#x27; }, (err) =&#x3E; {
  assert.strictEqual(err.name, &#x27;InvalidSlugError&#x27;);
  gitCheckerMock.verify();
  travisCheckerMock.verify();
  done();
});
assert.strictEqual(retVal, undefined);</code></pre></dd>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
